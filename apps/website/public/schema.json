{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AmdConfig": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "exportInteropAnnotation": {
          "description": "Emits `cjs-module-lexer` annotation\n`cjs-module-lexer` is used in Node.js core for detecting the named exports available when importing a CJS module into ESM.\nswc will emit `cjs-module-lexer` detectable annotation with this option enabled.\n\nDefaults to `true` if import_interop is Node, else `false`",
          "type": "boolean"
        },
        "ignoreDynamic": {
          "description": "If set to true, dynamic imports will be preserved.",
          "type": "boolean"
        },
        "importInterop": {
          "description": "Defaults to `swc`.\n\nCommonJS modules and ECMAScript modules are not fully compatible.\nHowever, compilers, bundlers and JavaScript runtimes developed different strategies\nto make them work together as well as possible.\n\n- `swc` (alias: `babel`)\n\nWhen using exports with `swc` a non-enumerable `__esModule` property is exported\nThis property is then used to determine if the import is the default export\nor if it contains the default export.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar _foo = _interop_require_default(require(\"foo\"));\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```\n\nWhen this import interop is used, if both the imported and the importer module are compiled\nwith swc they behave as if none of them was compiled.\n\nThis is the default behavior.\n\n- `node`\n\nWhen importing CommonJS files (either directly written in CommonJS, or generated with a compiler)\nNode.js always binds the `default` export to the value of `module.exports`.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo;\n_bar.bar;\n```\nThis is not exactly the same as what Node.js does since swc allows accessing any property of `module.exports`\nas a named export, while Node.js only allows importing statically analyzable properties of `module.exports`.\nHowever, any import working in Node.js will also work when compiled with swc using `importInterop: \"node\"`.\n\n- `none`\n\nIf you know that the imported file has been transformed with a compiler that stores the `default` export on\n`exports.default` (such as swc or Babel), you can safely omit the `_interop_require_default` helper.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```",
          "enum": ["babel", "node", "none", "swc"],
          "type": "string"
        },
        "lazy": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Changes Babel's compiled import statements to be lazily evaluated when their imported bindings are used for the first time.\n\nThis can improve initial load time of your module because evaluating dependencies up\n front is sometimes entirely un-necessary. This is especially the case when implementing\n a library module.\n\n\nThe value of `lazy` has a few possible effects:\n\n - `false` - No lazy initialization of any imported module.\n - `true` - Do not lazy-initialize local `./foo` imports, but lazy-init `foo` dependencies.\n\nLocal paths are much more likely to have circular dependencies, which may break if loaded lazily,\nso they are not lazy by default, whereas dependencies between independent modules are rarely cyclical.\n\n - `Array<string>` - Lazy-initialize all imports with source matching one of the given strings.\n\n-----\n\nThe two cases where imports can never be lazy are:\n\n - `import \"foo\";`\n\nSide-effect imports are automatically non-lazy since their very existence means\n that there is no binding to later kick off initialization.\n\n - `export * from \"foo\"`\n\nRe-exporting all names requires up-front execution because otherwise there is no\nway to know what names need to be exported.\n\nDefaults to `false`."
        },
        "moduleId": {
          "type": "string"
        },
        "noInterop": {
          "type": "boolean"
        },
        "outFileExtension": {
          "description": "Output extension for generated files.\n\nDefaults to `js`.",
          "enum": ["cjs", "js", "mjs"],
          "type": "string"
        },
        "preserveImportMeta": {
          "type": "boolean"
        },
        "strict": {
          "description": "By default, when using exports with babel a non-enumerable `__esModule`\nproperty is exported. In some cases this property is used to determine\nif the import is the default export or if it contains the default export.\n\nIn order to prevent the __esModule property from being exported, you\n can set the strict option to true.\n\nDefaults to `false`.",
          "type": "boolean"
        },
        "strictMode": {
          "description": "Emits 'use strict' directive.\n\nDefaults to `true`.",
          "type": "boolean"
        },
        "type": {
          "const": "amd",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Assumptions": {
      "properties": {
        "arrayLikeIsIterable": {
          "description": "https://babeljs.io/docs/en/assumptions#arraylikeisiterable",
          "type": "boolean"
        },
        "constantReexports": {
          "description": "https://babeljs.io/docs/en/assumptions#constantreexports",
          "type": "boolean"
        },
        "constantSuper": {
          "description": "https://babeljs.io/docs/en/assumptions#constantsuper",
          "type": "boolean"
        },
        "enumerableModuleMeta": {
          "description": "https://babeljs.io/docs/en/assumptions#enumerablemodulemeta",
          "type": "boolean"
        },
        "ignoreFunctionLength": {
          "description": "https://babeljs.io/docs/en/assumptions#ignorefunctionlength",
          "type": "boolean"
        },
        "ignoreFunctionName": {
          "type": "boolean"
        },
        "ignoreToPrimitiveHint": {
          "description": "https://babeljs.io/docs/en/assumptions#ignoretoprimitivehint",
          "type": "boolean"
        },
        "iterableIsArray": {
          "description": "https://babeljs.io/docs/en/assumptions#iterableisarray",
          "type": "boolean"
        },
        "mutableTemplateObject": {
          "description": "https://babeljs.io/docs/en/assumptions#mutabletemplateobject",
          "type": "boolean"
        },
        "noClassCalls": {
          "description": "https://babeljs.io/docs/en/assumptions#noclasscalls",
          "type": "boolean"
        },
        "noDocumentAll": {
          "description": "https://babeljs.io/docs/en/assumptions#nodocumentall",
          "type": "boolean"
        },
        "noIncompleteNsImportDetection": {
          "description": "https://babeljs.io/docs/en/assumptions#noincompletensimportdetection",
          "type": "boolean"
        },
        "noNewArrows": {
          "description": "https://babeljs.io/docs/en/assumptions#nonewarrows",
          "type": "boolean"
        },
        "objectRestNoSymbols": {
          "description": "https://babeljs.io/docs/en/assumptions#objectrestnosymbols",
          "type": "boolean"
        },
        "privateFieldsAsProperties": {
          "description": "https://babeljs.io/docs/en/assumptions#privatefieldsasproperties",
          "type": "boolean"
        },
        "pureGetters": {
          "description": "https://babeljs.io/docs/en/assumptions#puregetters",
          "type": "boolean"
        },
        "setClassMethods": {
          "description": "https://babeljs.io/docs/en/assumptions#setclassmethods",
          "type": "boolean"
        },
        "setComputedProperties": {
          "description": "https://babeljs.io/docs/en/assumptions#setcomputedproperties",
          "type": "boolean"
        },
        "setPublicClassFields": {
          "description": "https://babeljs.io/docs/en/assumptions#setpublicclassfields",
          "type": "boolean"
        },
        "setSpreadProperties": {
          "description": "https://babeljs.io/docs/en/assumptions#setspreadproperties",
          "type": "boolean"
        },
        "skipForOfIteratorClosing": {
          "description": "https://babeljs.io/docs/en/assumptions#skipforofiteratorclosing",
          "type": "boolean"
        },
        "superIsCallableConstructor": {
          "description": "https://babeljs.io/docs/en/assumptions#superiscallableconstructor",
          "type": "boolean"
        },
        "tsEnumIsReadonly": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CallerOptions": {
      "additionalProperties": {},
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "CommonJsConfig": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "exportInteropAnnotation": {
          "description": "Emits `cjs-module-lexer` annotation\n`cjs-module-lexer` is used in Node.js core for detecting the named exports available when importing a CJS module into ESM.\nswc will emit `cjs-module-lexer` detectable annotation with this option enabled.\n\nDefaults to `true` if import_interop is Node, else `false`",
          "type": "boolean"
        },
        "ignoreDynamic": {
          "description": "If set to true, dynamic imports will be preserved.",
          "type": "boolean"
        },
        "importInterop": {
          "description": "Defaults to `swc`.\n\nCommonJS modules and ECMAScript modules are not fully compatible.\nHowever, compilers, bundlers and JavaScript runtimes developed different strategies\nto make them work together as well as possible.\n\n- `swc` (alias: `babel`)\n\nWhen using exports with `swc` a non-enumerable `__esModule` property is exported\nThis property is then used to determine if the import is the default export\nor if it contains the default export.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar _foo = _interop_require_default(require(\"foo\"));\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```\n\nWhen this import interop is used, if both the imported and the importer module are compiled\nwith swc they behave as if none of them was compiled.\n\nThis is the default behavior.\n\n- `node`\n\nWhen importing CommonJS files (either directly written in CommonJS, or generated with a compiler)\nNode.js always binds the `default` export to the value of `module.exports`.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo;\n_bar.bar;\n```\nThis is not exactly the same as what Node.js does since swc allows accessing any property of `module.exports`\nas a named export, while Node.js only allows importing statically analyzable properties of `module.exports`.\nHowever, any import working in Node.js will also work when compiled with swc using `importInterop: \"node\"`.\n\n- `none`\n\nIf you know that the imported file has been transformed with a compiler that stores the `default` export on\n`exports.default` (such as swc or Babel), you can safely omit the `_interop_require_default` helper.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```",
          "enum": ["babel", "node", "none", "swc"],
          "type": "string"
        },
        "lazy": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Changes Babel's compiled import statements to be lazily evaluated when their imported bindings are used for the first time.\n\nThis can improve initial load time of your module because evaluating dependencies up\n front is sometimes entirely un-necessary. This is especially the case when implementing\n a library module.\n\n\nThe value of `lazy` has a few possible effects:\n\n - `false` - No lazy initialization of any imported module.\n - `true` - Do not lazy-initialize local `./foo` imports, but lazy-init `foo` dependencies.\n\nLocal paths are much more likely to have circular dependencies, which may break if loaded lazily,\nso they are not lazy by default, whereas dependencies between independent modules are rarely cyclical.\n\n - `Array<string>` - Lazy-initialize all imports with source matching one of the given strings.\n\n-----\n\nThe two cases where imports can never be lazy are:\n\n - `import \"foo\";`\n\nSide-effect imports are automatically non-lazy since their very existence means\n that there is no binding to later kick off initialization.\n\n - `export * from \"foo\"`\n\nRe-exporting all names requires up-front execution because otherwise there is no\nway to know what names need to be exported.\n\nDefaults to `false`."
        },
        "noInterop": {
          "type": "boolean"
        },
        "outFileExtension": {
          "description": "Output extension for generated files.\n\nDefaults to `js`.",
          "enum": ["cjs", "js", "mjs"],
          "type": "string"
        },
        "preserveImportMeta": {
          "type": "boolean"
        },
        "strict": {
          "description": "By default, when using exports with babel a non-enumerable `__esModule`\nproperty is exported. In some cases this property is used to determine\nif the import is the default export or if it contains the default export.\n\nIn order to prevent the __esModule property from being exported, you\n can set the strict option to true.\n\nDefaults to `false`.",
          "type": "boolean"
        },
        "strictMode": {
          "description": "Emits 'use strict' directive.\n\nDefaults to `true`.",
          "type": "boolean"
        },
        "type": {
          "const": "commonjs",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConstModulesConfig": {
      "description": "- `import { DEBUG } from '@ember/env-flags';`\n- `import { FEATURE_A, FEATURE_B } from '@ember/features';`\n\nSee: https://github.com/swc-project/swc/issues/18#issuecomment-466272558",
      "properties": {
        "globals": {
          "additionalProperties": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "EnvConfig": {
      "description": "Configuration ported from babel-preset-env",
      "properties": {
        "bugfixes": {
          "description": "Transpiles the broken syntax to the closest non-broken modern syntax\n\nDefaults to false.",
          "type": "boolean"
        },
        "coreJs": {
          "description": "The version of the used core js.",
          "type": "string"
        },
        "debug": {
          "type": "boolean"
        },
        "dynamicImport": {
          "type": "boolean"
        },
        "exclude": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "forceAllTransforms": {
          "description": "Enable all transforms",
          "type": "boolean"
        },
        "include": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "loose": {
          "type": "boolean"
        },
        "mode": {
          "enum": ["entry", "usage"],
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "shippedProposals": {
          "type": "boolean"
        },
        "skip": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "targets": {}
      },
      "type": "object"
    },
    "Es6Config": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "exportInteropAnnotation": {
          "description": "Emits `cjs-module-lexer` annotation\n`cjs-module-lexer` is used in Node.js core for detecting the named exports available when importing a CJS module into ESM.\nswc will emit `cjs-module-lexer` detectable annotation with this option enabled.\n\nDefaults to `true` if import_interop is Node, else `false`",
          "type": "boolean"
        },
        "ignoreDynamic": {
          "description": "If set to true, dynamic imports will be preserved.",
          "type": "boolean"
        },
        "importInterop": {
          "description": "Defaults to `swc`.\n\nCommonJS modules and ECMAScript modules are not fully compatible.\nHowever, compilers, bundlers and JavaScript runtimes developed different strategies\nto make them work together as well as possible.\n\n- `swc` (alias: `babel`)\n\nWhen using exports with `swc` a non-enumerable `__esModule` property is exported\nThis property is then used to determine if the import is the default export\nor if it contains the default export.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar _foo = _interop_require_default(require(\"foo\"));\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```\n\nWhen this import interop is used, if both the imported and the importer module are compiled\nwith swc they behave as if none of them was compiled.\n\nThis is the default behavior.\n\n- `node`\n\nWhen importing CommonJS files (either directly written in CommonJS, or generated with a compiler)\nNode.js always binds the `default` export to the value of `module.exports`.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo;\n_bar.bar;\n```\nThis is not exactly the same as what Node.js does since swc allows accessing any property of `module.exports`\nas a named export, while Node.js only allows importing statically analyzable properties of `module.exports`.\nHowever, any import working in Node.js will also work when compiled with swc using `importInterop: \"node\"`.\n\n- `none`\n\nIf you know that the imported file has been transformed with a compiler that stores the `default` export on\n`exports.default` (such as swc or Babel), you can safely omit the `_interop_require_default` helper.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```",
          "enum": ["babel", "node", "none", "swc"],
          "type": "string"
        },
        "lazy": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Changes Babel's compiled import statements to be lazily evaluated when their imported bindings are used for the first time.\n\nThis can improve initial load time of your module because evaluating dependencies up\n front is sometimes entirely un-necessary. This is especially the case when implementing\n a library module.\n\n\nThe value of `lazy` has a few possible effects:\n\n - `false` - No lazy initialization of any imported module.\n - `true` - Do not lazy-initialize local `./foo` imports, but lazy-init `foo` dependencies.\n\nLocal paths are much more likely to have circular dependencies, which may break if loaded lazily,\nso they are not lazy by default, whereas dependencies between independent modules are rarely cyclical.\n\n - `Array<string>` - Lazy-initialize all imports with source matching one of the given strings.\n\n-----\n\nThe two cases where imports can never be lazy are:\n\n - `import \"foo\";`\n\nSide-effect imports are automatically non-lazy since their very existence means\n that there is no binding to later kick off initialization.\n\n - `export * from \"foo\"`\n\nRe-exporting all names requires up-front execution because otherwise there is no\nway to know what names need to be exported.\n\nDefaults to `false`."
        },
        "noInterop": {
          "type": "boolean"
        },
        "outFileExtension": {
          "description": "Output extension for generated files.\n\nDefaults to `js`.",
          "enum": ["cjs", "js", "mjs"],
          "type": "string"
        },
        "preserveImportMeta": {
          "type": "boolean"
        },
        "strict": {
          "description": "By default, when using exports with babel a non-enumerable `__esModule`\nproperty is exported. In some cases this property is used to determine\nif the import is the default export or if it contains the default export.\n\nIn order to prevent the __esModule property from being exported, you\n can set the strict option to true.\n\nDefaults to `false`.",
          "type": "boolean"
        },
        "strictMode": {
          "description": "Emits 'use strict' directive.\n\nDefaults to `true`.",
          "type": "boolean"
        },
        "type": {
          "const": "es6",
          "type": "string"
        }
      },
      "type": "object"
    },
    "EsParserConfig": {
      "properties": {
        "allowReturnOutsideFunction": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "allowSuperOutsideMethod": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "autoAccessors": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "classPrivateProperty": {
          "type": "boolean"
        },
        "classProperty": {
          "type": "boolean"
        },
        "decorators": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "decoratorsBeforeExport": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "dynamicImport": {
          "type": "boolean"
        },
        "explicitResourceManagement": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "exportDefaultFrom": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "exportNamespaceFrom": {
          "type": "boolean"
        },
        "functionBind": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "importAssertions": {
          "type": "boolean"
        },
        "importAttributes": {
          "description": "Defaults to `false`",
          "type": "boolean"
        },
        "importMeta": {
          "type": "boolean"
        },
        "jsx": {
          "description": "Defaults to false.",
          "type": "boolean"
        },
        "nullishCoalescing": {
          "type": "boolean"
        },
        "numericSeparator": {
          "type": "boolean"
        },
        "optionalChaining": {
          "type": "boolean"
        },
        "privateMethod": {
          "type": "boolean"
        },
        "syntax": {
          "const": "ecmascript",
          "type": "string"
        },
        "topLevelAwait": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GlobalPassOption": {
      "description": "Options for inline-global pass.",
      "properties": {
        "envs": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/Record<string,string>"
            }
          ],
          "description": "Names of environment variables that should be inlined with the value of corresponding env during build.\n\nDefaults to `[\"NODE_ENV\", \"SWC_ENV\"]`"
        },
        "typeofs": {
          "$ref": "#/definitions/Record<string,string>",
          "description": "Replaces typeof calls for passed variables with corresponding value\n\ne.g. `{ window: 'object' }`"
        },
        "vars": {
          "$ref": "#/definitions/Record<string,string>",
          "description": "Global variables that should be inlined with passed value.\n\ne.g. `{ __DEBUG__: true }`"
        }
      },
      "type": "object"
    },
    "JsFormatOptions": {
      "description": "These properties are mostly not implemented yet,\nbut it exists to support passing terser config to swc minify\nwithout modification.",
      "properties": {
        "asciiOnly": {
          "default": false,
          "description": "Currently noop.",
          "type": "boolean"
        },
        "beautify": {
          "default": false,
          "description": "Currently noop.",
          "type": "boolean"
        },
        "braces": {
          "default": false,
          "description": "Currently noop.",
          "type": "boolean"
        },
        "comments": {
          "default": false,
          "description": "- `false`: removes all comments\n- `'some'`: preserves some comments\n- `'all'`: preserves all comments",
          "enum": ["all", false, "some"]
        },
        "ecma": {
          "$ref": "#/definitions/TerserEcmaVersion",
          "default": 5,
          "description": "Currently noop."
        },
        "indentLevel": {
          "description": "Currently noop.",
          "type": "number"
        },
        "indentStart": {
          "description": "Currently noop.",
          "type": "number"
        },
        "inlineScript": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "keepNumbers": {
          "description": "Currently noop.",
          "type": "number"
        },
        "keepQuotedProps": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "maxLineLen": {
          "anyOf": [
            {
              "const": false,
              "type": "boolean"
            },
            {
              "type": "number"
            }
          ],
          "description": "Currently noop."
        },
        "preamble": {
          "description": "Currently noop.",
          "type": "string"
        },
        "preserveAnnotations": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "quoteKeys": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "quoteStyle": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "safari10": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "semicolons": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "shebang": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "webkit": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "wrapFuncArgs": {
          "description": "Currently noop.",
          "type": "boolean"
        },
        "wrapIife": {
          "description": "Currently noop.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "JsMinifyOptions": {
      "properties": {
        "compress": {
          "anyOf": [
            {
              "$ref": "#/definitions/TerserCompressOptions"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "ecma": {
          "$ref": "#/definitions/TerserEcmaVersion"
        },
        "format": {
          "allOf": [
            {
              "$ref": "#/definitions/JsFormatOptions"
            },
            {
              "$ref": "#/definitions/ToSnakeCaseProperties<JsFormatOptions>"
            }
          ]
        },
        "inlineSourcesContent": {
          "type": "boolean"
        },
        "keep_classnames": {
          "type": "boolean"
        },
        "keep_fnames": {
          "type": "boolean"
        },
        "mangle": {
          "anyOf": [
            {
              "$ref": "#/definitions/TerserMangleOptions"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "module": {
          "enum": [false, true, "unknown"]
        },
        "outputPath": {
          "type": "string"
        },
        "safari10": {
          "type": "boolean"
        },
        "sourceMap": {
          "type": "boolean"
        },
        "toplevel": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "JscConfig": {
      "properties": {
        "assumptions": {
          "$ref": "#/definitions/Assumptions"
        },
        "baseUrl": {
          "type": "string"
        },
        "experimental": {
          "description": "This is experimental, and can be removed without a major version bump.",
          "properties": {
            "cacheRoot": {
              "description": "Specify the location where SWC stores its intermediate cache files.\nCurrently only transform plugin uses this. If not specified, SWC will\ncreate `.swc` directories.",
              "type": "string"
            },
            "disableAllLints": {
              "description": "Disable all lint rules.",
              "type": "boolean"
            },
            "disableBuiltinTransformsForInternalTesting": {
              "description": "Disable builtin transforms. If enabled, only Wasm plugins are used.",
              "type": "boolean"
            },
            "emitAssertForImportAttributes": {
              "description": "Use `assert` instead of `with` for imports and exports.\nThis option only works when `keepImportAttributes` is `true`.",
              "type": "boolean"
            },
            "emitIsolatedDts": {
              "description": "Emit isolated dts files for each module.",
              "type": "boolean"
            },
            "keepImportAssertions": {
              "description": "Keep import assertions.",
              "type": "boolean"
            },
            "keepImportAttributes": {
              "description": "Preserve `with` in imports and exports.",
              "type": "boolean"
            },
            "optimizeHygiene": {
              "type": "boolean"
            },
            "plugins": {
              "description": "List of custom transform plugins written in WebAssembly.\nFirst parameter of tuple indicates the name of the plugin - it can be either\na name of the npm package can be resolved, or absolute path to .wasm binary.\n\nSecond parameter of tuple is JSON based configuration for the plugin.",
              "items": {
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/definitions/Record<string,any>"
                  }
                ],
                "maxItems": 2,
                "minItems": 2,
                "type": "array"
              },
              "type": "array"
            },
            "runPluginFirst": {
              "description": "Run Wasm plugins before stripping TypeScript or decorators.\n\nSee https://github.com/swc-project/swc/issues/9132 for more details.",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "externalHelpers": {
          "description": "Use `@swc/helpers` instead of inline helpers.",
          "type": "boolean"
        },
        "keepClassNames": {
          "description": "Keep class names.",
          "type": "boolean"
        },
        "loose": {
          "type": "boolean"
        },
        "minify": {
          "$ref": "#/definitions/JsMinifyOptions"
        },
        "parser": {
          "$ref": "#/definitions/ParserConfig",
          "description": "Defaults to EsParserConfig"
        },
        "paths": {
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "type": "object"
        },
        "preserveAllComments": {
          "type": "boolean"
        },
        "target": {
          "$ref": "#/definitions/JscTarget",
          "description": "Defaults to `es3` (which enabled **all** pass)."
        },
        "transform": {
          "$ref": "#/definitions/TransformConfig"
        }
      },
      "type": "object"
    },
    "JscTarget": {
      "enum": [
        "es2015",
        "es2016",
        "es2017",
        "es2018",
        "es2019",
        "es2020",
        "es2021",
        "es2022",
        "es2023",
        "es2024",
        "es3",
        "es5",
        "esnext"
      ],
      "type": "string"
    },
    "MatchPattern": {
      "type": "object"
    },
    "ModuleConfig": {
      "anyOf": [
        {
          "$ref": "#/definitions/Es6Config"
        },
        {
          "$ref": "#/definitions/CommonJsConfig"
        },
        {
          "$ref": "#/definitions/UmdConfig"
        },
        {
          "$ref": "#/definitions/AmdConfig"
        },
        {
          "$ref": "#/definitions/NodeNextConfig"
        },
        {
          "$ref": "#/definitions/SystemjsConfig"
        }
      ]
    },
    "NodeNextConfig": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "exportInteropAnnotation": {
          "description": "Emits `cjs-module-lexer` annotation\n`cjs-module-lexer` is used in Node.js core for detecting the named exports available when importing a CJS module into ESM.\nswc will emit `cjs-module-lexer` detectable annotation with this option enabled.\n\nDefaults to `true` if import_interop is Node, else `false`",
          "type": "boolean"
        },
        "ignoreDynamic": {
          "description": "If set to true, dynamic imports will be preserved.",
          "type": "boolean"
        },
        "importInterop": {
          "description": "Defaults to `swc`.\n\nCommonJS modules and ECMAScript modules are not fully compatible.\nHowever, compilers, bundlers and JavaScript runtimes developed different strategies\nto make them work together as well as possible.\n\n- `swc` (alias: `babel`)\n\nWhen using exports with `swc` a non-enumerable `__esModule` property is exported\nThis property is then used to determine if the import is the default export\nor if it contains the default export.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar _foo = _interop_require_default(require(\"foo\"));\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```\n\nWhen this import interop is used, if both the imported and the importer module are compiled\nwith swc they behave as if none of them was compiled.\n\nThis is the default behavior.\n\n- `node`\n\nWhen importing CommonJS files (either directly written in CommonJS, or generated with a compiler)\nNode.js always binds the `default` export to the value of `module.exports`.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo;\n_bar.bar;\n```\nThis is not exactly the same as what Node.js does since swc allows accessing any property of `module.exports`\nas a named export, while Node.js only allows importing statically analyzable properties of `module.exports`.\nHowever, any import working in Node.js will also work when compiled with swc using `importInterop: \"node\"`.\n\n- `none`\n\nIf you know that the imported file has been transformed with a compiler that stores the `default` export on\n`exports.default` (such as swc or Babel), you can safely omit the `_interop_require_default` helper.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```",
          "enum": ["babel", "node", "none", "swc"],
          "type": "string"
        },
        "lazy": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Changes Babel's compiled import statements to be lazily evaluated when their imported bindings are used for the first time.\n\nThis can improve initial load time of your module because evaluating dependencies up\n front is sometimes entirely un-necessary. This is especially the case when implementing\n a library module.\n\n\nThe value of `lazy` has a few possible effects:\n\n - `false` - No lazy initialization of any imported module.\n - `true` - Do not lazy-initialize local `./foo` imports, but lazy-init `foo` dependencies.\n\nLocal paths are much more likely to have circular dependencies, which may break if loaded lazily,\nso they are not lazy by default, whereas dependencies between independent modules are rarely cyclical.\n\n - `Array<string>` - Lazy-initialize all imports with source matching one of the given strings.\n\n-----\n\nThe two cases where imports can never be lazy are:\n\n - `import \"foo\";`\n\nSide-effect imports are automatically non-lazy since their very existence means\n that there is no binding to later kick off initialization.\n\n - `export * from \"foo\"`\n\nRe-exporting all names requires up-front execution because otherwise there is no\nway to know what names need to be exported.\n\nDefaults to `false`."
        },
        "noInterop": {
          "type": "boolean"
        },
        "outFileExtension": {
          "description": "Output extension for generated files.\n\nDefaults to `js`.",
          "enum": ["cjs", "js", "mjs"],
          "type": "string"
        },
        "preserveImportMeta": {
          "type": "boolean"
        },
        "strict": {
          "description": "By default, when using exports with babel a non-enumerable `__esModule`\nproperty is exported. In some cases this property is used to determine\nif the import is the default export or if it contains the default export.\n\nIn order to prevent the __esModule property from being exported, you\n can set the strict option to true.\n\nDefaults to `false`.",
          "type": "boolean"
        },
        "strictMode": {
          "description": "Emits 'use strict' directive.\n\nDefaults to `true`.",
          "type": "boolean"
        },
        "type": {
          "const": "nodenext",
          "type": "string"
        }
      },
      "type": "object"
    },
    "OptimizerConfig": {
      "properties": {
        "globals": {
          "$ref": "#/definitions/GlobalPassOption"
        },
        "jsonify": {
          "properties": {
            "minCost": {
              "type": "number"
            }
          },
          "type": "object"
        },
        "simplify": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ParserConfig": {
      "anyOf": [
        {
          "$ref": "#/definitions/TsParserConfig"
        },
        {
          "$ref": "#/definitions/EsParserConfig"
        }
      ]
    },
    "Plugin": {
      "type": "object"
    },
    "ReactConfig": {
      "properties": {
        "development": {
          "description": "Toggles plugins that aid in development, such as",
          "type": "boolean"
        },
        "importSource": {
          "description": "Declares the module specifier to be used for importing the `jsx` and `jsxs` factory functions when using `runtime` 'automatic'",
          "type": "string"
        },
        "pragma": {
          "description": "Replace the function used when compiling JSX expressions.\n\nDefaults to `React.createElement`.",
          "type": "string"
        },
        "pragmaFrag": {
          "description": "Replace the component used when compiling JSX fragments.\n\nDefaults to `React.Fragment`",
          "type": "string"
        },
        "refresh": {
          "anyOf": [
            {
              "properties": {
                "emitFullSignatures": {
                  "description": "Flag to emit full signatures.\n\nDefaults to `false`",
                  "type": "boolean"
                },
                "refreshReg": {
                  "description": "Identifier for the `react-refresh` register function.\n\nDefaults to `$RefreshReg$`",
                  "type": "string"
                },
                "refreshSig": {
                  "description": "Identifier for the `react-refresh` signature function.\n\nDefaults to `$RefreshSig$`",
                  "type": "string"
                }
              },
              "type": "object"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Enable fast refresh feature for React app"
        },
        "runtime": {
          "description": "jsx runtime",
          "enum": ["automatic", "classic"],
          "type": "string"
        },
        "throwIfNamespace": {
          "description": "Toggles whether or not to throw an error if a XML namespaced tag name is used. For example:\n`<f:image />`\n\nThough the JSX spec allows this, it is disabled by default since React's\nJSX does not currently have support for it.",
          "type": "boolean"
        },
        "useBuiltins": {
          "description": "Use `Object.assign()` instead of `_extends`. Defaults to false.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Record<string,any>": {
      "type": "object"
    },
    "Record<string,string>": {
      "type": "object"
    },
    "SystemjsConfig": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "type": {
          "const": "systemjs",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TerserCompressOptions": {
      "properties": {
        "arguments": {
          "type": "boolean"
        },
        "arrows": {
          "type": "boolean"
        },
        "booleans": {
          "type": "boolean"
        },
        "booleans_as_integers": {
          "type": "boolean"
        },
        "collapse_vars": {
          "type": "boolean"
        },
        "comparisons": {
          "type": "boolean"
        },
        "computed_props": {
          "type": "boolean"
        },
        "conditionals": {
          "type": "boolean"
        },
        "const_to_let": {
          "type": "boolean"
        },
        "dead_code": {
          "type": "boolean"
        },
        "defaults": {
          "type": "boolean"
        },
        "directives": {
          "type": "boolean"
        },
        "drop_console": {
          "type": "boolean"
        },
        "drop_debugger": {
          "type": "boolean"
        },
        "ecma": {
          "$ref": "#/definitions/TerserEcmaVersion"
        },
        "evaluate": {
          "type": "boolean"
        },
        "expression": {
          "type": "boolean"
        },
        "global_defs": {},
        "hoist_funs": {
          "type": "boolean"
        },
        "hoist_props": {
          "type": "boolean"
        },
        "hoist_vars": {
          "type": "boolean"
        },
        "ie8": {
          "type": "boolean"
        },
        "if_return": {
          "type": "boolean"
        },
        "inline": {
          "enum": [0, 1, 2, 3],
          "type": "number"
        },
        "join_vars": {
          "type": "boolean"
        },
        "keep_classnames": {
          "type": "boolean"
        },
        "keep_fargs": {
          "type": "boolean"
        },
        "keep_fnames": {
          "type": "boolean"
        },
        "keep_infinity": {
          "type": "boolean"
        },
        "loops": {
          "type": "boolean"
        },
        "module": {
          "type": "boolean"
        },
        "negate_iife": {
          "type": "boolean"
        },
        "passes": {
          "type": "number"
        },
        "properties": {
          "type": "boolean"
        },
        "pure_funcs": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pure_getters": {},
        "reduce_funcs": {
          "type": "boolean"
        },
        "reduce_vars": {
          "type": "boolean"
        },
        "sequences": {},
        "side_effects": {
          "type": "boolean"
        },
        "switches": {
          "type": "boolean"
        },
        "top_retain": {},
        "toplevel": {},
        "typeofs": {
          "type": "boolean"
        },
        "unsafe": {
          "type": "boolean"
        },
        "unsafe_arrows": {
          "type": "boolean"
        },
        "unsafe_comps": {
          "type": "boolean"
        },
        "unsafe_function": {
          "type": "boolean"
        },
        "unsafe_math": {
          "type": "boolean"
        },
        "unsafe_methods": {
          "type": "boolean"
        },
        "unsafe_passes": {
          "type": "boolean"
        },
        "unsafe_proto": {
          "type": "boolean"
        },
        "unsafe_regexp": {
          "type": "boolean"
        },
        "unsafe_symbols": {
          "type": "boolean"
        },
        "unsafe_undefined": {
          "type": "boolean"
        },
        "unused": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TerserEcmaVersion": {
      "type": ["string", "number"]
    },
    "TerserMangleOptions": {
      "properties": {
        "ie8": {
          "type": "boolean"
        },
        "keepClassNames": {
          "description": "Pass `true` to not mangle class names.",
          "type": "boolean"
        },
        "keepFnNames": {
          "description": "Pass `true` to not mangle function names.",
          "type": "boolean"
        },
        "keepPrivateProps": {
          "description": "Pass `true` to not mangle private props.",
          "type": "boolean"
        },
        "keep_classnames": {
          "type": "boolean"
        },
        "keep_fnames": {
          "type": "boolean"
        },
        "keep_private_props": {
          "type": "boolean"
        },
        "props": {
          "$ref": "#/definitions/TerserManglePropertiesOptions"
        },
        "reserved": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "safari10": {
          "type": "boolean"
        },
        "topLevel": {
          "description": "Pass `true` to mangle names declared in the top level scope.",
          "type": "boolean"
        },
        "toplevel": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TerserManglePropertiesOptions": {
      "type": "object"
    },
    "ToSnakeCaseProperties<JsFormatOptions>": {
      "properties": {
        "ascii_only": {
          "type": "boolean"
        },
        "beautify": {
          "type": "boolean"
        },
        "braces": {
          "type": "boolean"
        },
        "comments": {
          "enum": ["all", false, "some"]
        },
        "ecma": {
          "$ref": "#/definitions/TerserEcmaVersion"
        },
        "indent_level": {
          "type": "number"
        },
        "indent_start": {
          "type": "number"
        },
        "inline_script": {
          "type": "boolean"
        },
        "keep_numbers": {
          "type": "number"
        },
        "keep_quoted_props": {
          "type": "boolean"
        },
        "max_line_len": {
          "anyOf": [
            {
              "const": false,
              "type": "boolean"
            },
            {
              "type": "number"
            }
          ]
        },
        "preamble": {
          "type": "string"
        },
        "preserve_annotations": {
          "type": "boolean"
        },
        "quote_keys": {
          "type": "boolean"
        },
        "quote_style": {
          "type": "boolean"
        },
        "safari10": {
          "type": "boolean"
        },
        "semicolons": {
          "type": "boolean"
        },
        "shebang": {
          "type": "boolean"
        },
        "webkit": {
          "type": "boolean"
        },
        "wrap_func_args": {
          "type": "boolean"
        },
        "wrap_iife": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TransformConfig": {
      "description": "Options for transform.",
      "properties": {
        "constModules": {
          "$ref": "#/definitions/ConstModulesConfig"
        },
        "decoratorMetadata": {
          "description": "https://swc.rs/docs/configuration/compilation#jsctransformdecoratormetadata",
          "type": "boolean"
        },
        "decoratorVersion": {
          "description": "https://swc.rs/docs/configuration/compilation#jsctransformdecoratorversion",
          "enum": ["2021-12", "2022-03"],
          "type": "string"
        },
        "legacyDecorator": {
          "description": "https://swc.rs/docs/configuration/compilation#jsctransformlegacydecorator",
          "type": "boolean"
        },
        "optimizer": {
          "$ref": "#/definitions/OptimizerConfig",
          "description": "Defaults to null, which skips optimizer pass."
        },
        "react": {
          "$ref": "#/definitions/ReactConfig",
          "description": "Effective only if `syntax` supports ƒ."
        },
        "treatConstEnumAsEnum": {
          "type": "boolean"
        },
        "useDefineForClassFields": {
          "description": "https://www.typescriptlang.org/tsconfig#useDefineForClassFields",
          "type": "boolean"
        },
        "verbatimModuleSyntax": {
          "description": "https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TsParserConfig": {
      "properties": {
        "decorators": {
          "description": "Defaults to `false`.",
          "type": "boolean"
        },
        "dynamicImport": {
          "type": "boolean"
        },
        "syntax": {
          "const": "typescript",
          "type": "string"
        },
        "tsx": {
          "description": "Defaults to `false`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "UmdConfig": {
      "properties": {
        "allowTopLevelThis": {
          "type": "boolean"
        },
        "exportInteropAnnotation": {
          "description": "Emits `cjs-module-lexer` annotation\n`cjs-module-lexer` is used in Node.js core for detecting the named exports available when importing a CJS module into ESM.\nswc will emit `cjs-module-lexer` detectable annotation with this option enabled.\n\nDefaults to `true` if import_interop is Node, else `false`",
          "type": "boolean"
        },
        "globals": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        "ignoreDynamic": {
          "description": "If set to true, dynamic imports will be preserved.",
          "type": "boolean"
        },
        "importInterop": {
          "description": "Defaults to `swc`.\n\nCommonJS modules and ECMAScript modules are not fully compatible.\nHowever, compilers, bundlers and JavaScript runtimes developed different strategies\nto make them work together as well as possible.\n\n- `swc` (alias: `babel`)\n\nWhen using exports with `swc` a non-enumerable `__esModule` property is exported\nThis property is then used to determine if the import is the default export\nor if it contains the default export.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar _foo = _interop_require_default(require(\"foo\"));\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```\n\nWhen this import interop is used, if both the imported and the importer module are compiled\nwith swc they behave as if none of them was compiled.\n\nThis is the default behavior.\n\n- `node`\n\nWhen importing CommonJS files (either directly written in CommonJS, or generated with a compiler)\nNode.js always binds the `default` export to the value of `module.exports`.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo;\n_bar.bar;\n```\nThis is not exactly the same as what Node.js does since swc allows accessing any property of `module.exports`\nas a named export, while Node.js only allows importing statically analyzable properties of `module.exports`.\nHowever, any import working in Node.js will also work when compiled with swc using `importInterop: \"node\"`.\n\n- `none`\n\nIf you know that the imported file has been transformed with a compiler that stores the `default` export on\n`exports.default` (such as swc or Babel), you can safely omit the `_interop_require_default` helper.\n\n```javascript\nimport foo from \"foo\";\nimport { bar } from \"bar\";\nfoo;\nbar;\n\n// Is compiled to ...\n\n\"use strict\";\n\nvar _foo = require(\"foo\");\nvar _bar = require(\"bar\");\n\n_foo.default;\n_bar.bar;\n```",
          "enum": ["babel", "node", "none", "swc"],
          "type": "string"
        },
        "lazy": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "boolean"
            }
          ],
          "description": "Changes Babel's compiled import statements to be lazily evaluated when their imported bindings are used for the first time.\n\nThis can improve initial load time of your module because evaluating dependencies up\n front is sometimes entirely un-necessary. This is especially the case when implementing\n a library module.\n\n\nThe value of `lazy` has a few possible effects:\n\n - `false` - No lazy initialization of any imported module.\n - `true` - Do not lazy-initialize local `./foo` imports, but lazy-init `foo` dependencies.\n\nLocal paths are much more likely to have circular dependencies, which may break if loaded lazily,\nso they are not lazy by default, whereas dependencies between independent modules are rarely cyclical.\n\n - `Array<string>` - Lazy-initialize all imports with source matching one of the given strings.\n\n-----\n\nThe two cases where imports can never be lazy are:\n\n - `import \"foo\";`\n\nSide-effect imports are automatically non-lazy since their very existence means\n that there is no binding to later kick off initialization.\n\n - `export * from \"foo\"`\n\nRe-exporting all names requires up-front execution because otherwise there is no\nway to know what names need to be exported.\n\nDefaults to `false`."
        },
        "noInterop": {
          "type": "boolean"
        },
        "outFileExtension": {
          "description": "Output extension for generated files.\n\nDefaults to `js`.",
          "enum": ["cjs", "js", "mjs"],
          "type": "string"
        },
        "preserveImportMeta": {
          "type": "boolean"
        },
        "strict": {
          "description": "By default, when using exports with babel a non-enumerable `__esModule`\nproperty is exported. In some cases this property is used to determine\nif the import is the default export or if it contains the default export.\n\nIn order to prevent the __esModule property from being exported, you\n can set the strict option to true.\n\nDefaults to `false`.",
          "type": "boolean"
        },
        "strictMode": {
          "description": "Emits 'use strict' directive.\n\nDefaults to `true`.",
          "type": "boolean"
        },
        "type": {
          "const": "umd",
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "description": "Programmatic options.",
  "properties": {
    "caller": {
      "$ref": "#/definitions/CallerOptions"
    },
    "configFile": {
      "description": "Defaults to searching for a default `.swcrc` file, but can\nbe passed the path of any JS or JSON5 config file.\n\n\nNOTE: This option does not affect loading of .swcrc files,\nso while it may be tempting to do configFile: \"./foo/.swcrc\",\nit is not recommended. If the given .swcrc is loaded via the\nstandard file-relative logic, you'll end up loading the same\nconfig file twice, merging it with itself. If you are linking\na specific config file, it is recommended to stick with a\nnaming scheme that is independent of the \"swcrc\" name.\n\nDefaults to `path.resolve(opts.root, \".swcrc\")`",
      "type": ["string", "boolean"]
    },
    "cwd": {
      "description": "The working directory that all paths in the programmatic\noptions will be resolved relative to.\n\nDefaults to `process.cwd()`.",
      "type": "string"
    },
    "env": {
      "$ref": "#/definitions/EnvConfig"
    },
    "envName": {
      "description": "The current active environment used during configuration loading.\nThis value is used as the key when resolving \"env\" configs,\nand is also available inside configuration functions, plugins,\nand presets, via the api.env() function.\n\nDefaults to `process.env.SWC_ENV || process.env.NODE_ENV || \"development\"`",
      "type": "string"
    },
    "exclude": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "string"
        }
      ],
      "description": "Note: The type is string because it follows rust's regex syntax."
    },
    "filename": {
      "description": "The filename associated with the code currently being compiled,\nif there is one. The filename is optional, but not all of Swc's\nfunctionality is available when the filename is unknown, because a\nsubset of options rely on the filename for their functionality.\n\nThe three primary cases users could run into are:\n\n- The filename is exposed to plugins. Some plugins may require the\npresence of the filename.\n- Options like \"test\", \"exclude\", and \"ignore\" require the filename\nfor string/RegExp matching.\n- .swcrc files are loaded relative to the file being compiled.\nIf this option is omitted, Swc will behave as if swcrc: false has been set.",
      "type": "string"
    },
    "inlineSourcesContent": {
      "type": "boolean"
    },
    "inputSourceMap": {
      "description": "`true` will attempt to load an input sourcemap from the file itself, if it\ncontains a //# sourceMappingURL=... comment. If no map is found, or the\nmap fails to load and parse, it will be silently discarded.\n\n If an object is provided, it will be treated as the source map object itself.\n\nDefaults to `true`.",
      "type": ["string", "boolean"]
    },
    "isModule": {
      "enum": [false, true, "unknown"]
    },
    "jsc": {
      "$ref": "#/definitions/JscConfig"
    },
    "minify": {
      "type": "boolean"
    },
    "module": {
      "$ref": "#/definitions/ModuleConfig"
    },
    "outputPath": {
      "description": "Destination path. Note that this value is used only to fix source path\nof source map files and swc does not write output to this path.",
      "type": "string"
    },
    "plugin": {
      "$ref": "#/definitions/Plugin"
    },
    "root": {
      "description": "The initial path that will be processed based on the \"rootMode\" to\ndetermine the conceptual root folder for the current Swc project.\nThis is used in two primary cases:\n\n- The base directory when checking for the default \"configFile\" value\n- The default value for \"swcrcRoots\".\n\nDefaults to `opts.cwd`",
      "type": "string"
    },
    "rootMode": {
      "description": "This option, combined with the \"root\" value, defines how Swc chooses\nits project root. The different modes define different ways that Swc\ncan process the \"root\" value to get the final project root.\n\n\"root\" - Passes the \"root\" value through as unchanged.\n\"upward\" - Walks upward from the \"root\" directory, looking for a directory\ncontaining a swc.config.js file, and throws an error if a swc.config.js\nis not found.\n\"upward-optional\" - Walk upward from the \"root\" directory, looking for\na directory containing a swc.config.js file, and falls back to \"root\"\n if a swc.config.js is not found.\n\n\n\"root\" is the default mode because it avoids the risk that Swc\nwill accidentally load a swc.config.js that is entirely outside\nof the current project folder. If you use \"upward-optional\",\nbe aware that it will walk up the directory structure all the\nway to the filesystem root, and it is always possible that someone\nwill have a forgotten swc.config.js in their home directory,\nwhich could cause unexpected errors in your builds.\n\n\nUsers with monorepo project structures that run builds/tests on a\nper-package basis may well want to use \"upward\" since monorepos\noften have a swc.config.js in the project root. Running Swc\nin a monorepo subdirectory without \"upward\", will cause Swc\nto skip loading any swc.config.js files in the project root,\nwhich can lead to unexpected errors and compilation failure.",
      "enum": ["root", "upward", "upward-optional"],
      "type": "string"
    },
    "script": {
      "description": "If true, a file is parsed as a script instead of module.",
      "type": "boolean"
    },
    "sourceFileName": {
      "description": "The name to use for the file inside the source map object.\n\nDefaults to `path.basename(opts.filenameRelative)` when available, or `\"unknown\"`.",
      "type": "string"
    },
    "sourceMaps": {
      "description": "- true to generate a sourcemap for the code and include it in the result object.\n- \"inline\" to generate a sourcemap and append it as a data URL to the end of the code, but not include it in the result object.\n\n`swc-cli` overloads some of these to also affect how maps are written to disk:\n\n- true will write the map to a .map file on disk\n- \"inline\" will write the file directly, so it will have a data: containing the map\n- Note: These options are bit weird, so it may make the most sense to just use true\n and handle the rest in your own code, depending on your use case.",
      "enum": [false, "inline", true]
    },
    "sourceRoot": {
      "description": "The sourceRoot fields to set in the generated source map, if one is desired.",
      "type": "string"
    },
    "swcrc": {
      "description": "true will enable searching for configuration files relative to the \"filename\" provided to Swc.\n\nA swcrc value passed in the programmatic options will override one set within a configuration file.\n\nNote: .swcrc files are only loaded if the current \"filename\" is inside of\n a package that matches one of the \"swcrcRoots\" packages.\n\n\nDefaults to true as long as the filename option has been specified",
      "type": "boolean"
    },
    "swcrcRoots": {
      "anyOf": [
        {
          "$ref": "#/definitions/MatchPattern"
        },
        {
          "items": {
            "$ref": "#/definitions/MatchPattern"
          },
          "type": "array"
        },
        {
          "type": "boolean"
        }
      ],
      "description": "By default, Babel will only search for .babelrc files within the \"root\" package\n because otherwise Babel cannot know if a given .babelrc is meant to be loaded,\n or if it's \"plugins\" and \"presets\" have even been installed, since the file\n being compiled could be inside node_modules, or have been symlinked into the project.\n\n\nThis option allows users to provide a list of other packages that should be\nconsidered \"root\" packages when considering whether to load .babelrc files.\n\n\nFor example, a monorepo setup that wishes to allow individual packages\nto have their own configs might want to do\n\n\n\nDefaults to `opts.root`"
    },
    "test": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "string"
        }
      ],
      "description": "Note: The type is string because it follows rust's regex syntax."
    }
  },
  "type": "object"
}
